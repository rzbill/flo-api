// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: flo/v1/workqueues.proto

package flov1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkQueuesService_CreateWorkQueue_FullMethodName    = "/flo.v1.WorkQueuesService/CreateWorkQueue"
	WorkQueuesService_Enqueue_FullMethodName            = "/flo.v1.WorkQueuesService/Enqueue"
	WorkQueuesService_Dequeue_FullMethodName            = "/flo.v1.WorkQueuesService/Dequeue"
	WorkQueuesService_Complete_FullMethodName           = "/flo.v1.WorkQueuesService/Complete"
	WorkQueuesService_Fail_FullMethodName               = "/flo.v1.WorkQueuesService/Fail"
	WorkQueuesService_ExtendLease_FullMethodName        = "/flo.v1.WorkQueuesService/ExtendLease"
	WorkQueuesService_RegisterConsumer_FullMethodName   = "/flo.v1.WorkQueuesService/RegisterConsumer"
	WorkQueuesService_Heartbeat_FullMethodName          = "/flo.v1.WorkQueuesService/Heartbeat"
	WorkQueuesService_UnregisterConsumer_FullMethodName = "/flo.v1.WorkQueuesService/UnregisterConsumer"
	WorkQueuesService_ListConsumers_FullMethodName      = "/flo.v1.WorkQueuesService/ListConsumers"
	WorkQueuesService_ListPending_FullMethodName        = "/flo.v1.WorkQueuesService/ListPending"
	WorkQueuesService_Claim_FullMethodName              = "/flo.v1.WorkQueuesService/Claim"
	WorkQueuesService_GetWorkQueueStats_FullMethodName  = "/flo.v1.WorkQueuesService/GetWorkQueueStats"
	WorkQueuesService_ListReadyMessages_FullMethodName  = "/flo.v1.WorkQueuesService/ListReadyMessages"
	WorkQueuesService_ListDLQMessages_FullMethodName    = "/flo.v1.WorkQueuesService/ListDLQMessages"
	WorkQueuesService_ListCompleted_FullMethodName      = "/flo.v1.WorkQueuesService/ListCompleted"
	WorkQueuesService_Flush_FullMethodName              = "/flo.v1.WorkQueuesService/Flush"
)

// WorkQueuesServiceClient is the client API for WorkQueuesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkQueues provides a task queue facade with one-of-N delivery semantics.
// Unlike Streams (pub/sub fanout), WorkQueues ensure only one worker processes each message.
type WorkQueuesServiceClient interface {
	// Core Operations
	CreateWorkQueue(ctx context.Context, in *CreateWorkQueueRequest, opts ...grpc.CallOption) (*CreateWorkQueueResponse, error)
	Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error)
	Dequeue(ctx context.Context, in *DequeueRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DequeueResponse], error)
	Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error)
	Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*FailResponse, error)
	ExtendLease(ctx context.Context, in *ExtendLeaseRequest, opts ...grpc.CallOption) (*ExtendLeaseResponse, error)
	// Consumer Registry
	RegisterConsumer(ctx context.Context, in *RegisterConsumerRequest, opts ...grpc.CallOption) (*RegisterConsumerResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	UnregisterConsumer(ctx context.Context, in *UnregisterConsumerRequest, opts ...grpc.CallOption) (*UnregisterConsumerResponse, error)
	ListConsumers(ctx context.Context, in *ListConsumersRequest, opts ...grpc.CallOption) (*ListConsumersResponse, error)
	// Pending Entries List (PEL) & Claims
	ListPending(ctx context.Context, in *ListPendingRequest, opts ...grpc.CallOption) (*ListPendingResponse, error)
	Claim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error)
	// Admin & Introspection
	GetWorkQueueStats(ctx context.Context, in *GetWorkQueueStatsRequest, opts ...grpc.CallOption) (*GetWorkQueueStatsResponse, error)
	ListReadyMessages(ctx context.Context, in *ListReadyMessagesRequest, opts ...grpc.CallOption) (*ListReadyMessagesResponse, error)
	ListDLQMessages(ctx context.Context, in *ListWorkQueueDLQRequest, opts ...grpc.CallOption) (*ListWorkQueueDLQResponse, error)
	ListCompleted(ctx context.Context, in *ListCompletedRequest, opts ...grpc.CallOption) (*ListCompletedResponse, error)
	Flush(ctx context.Context, in *FlushWorkQueueRequest, opts ...grpc.CallOption) (*FlushWorkQueueResponse, error)
}

type workQueuesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkQueuesServiceClient(cc grpc.ClientConnInterface) WorkQueuesServiceClient {
	return &workQueuesServiceClient{cc}
}

func (c *workQueuesServiceClient) CreateWorkQueue(ctx context.Context, in *CreateWorkQueueRequest, opts ...grpc.CallOption) (*CreateWorkQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateWorkQueueResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_CreateWorkQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Enqueue(ctx context.Context, in *EnqueueRequest, opts ...grpc.CallOption) (*EnqueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnqueueResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Enqueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Dequeue(ctx context.Context, in *DequeueRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DequeueResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &WorkQueuesService_ServiceDesc.Streams[0], WorkQueuesService_Dequeue_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DequeueRequest, DequeueResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WorkQueuesService_DequeueClient = grpc.ServerStreamingClient[DequeueResponse]

func (c *workQueuesServiceClient) Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Fail(ctx context.Context, in *FailRequest, opts ...grpc.CallOption) (*FailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Fail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ExtendLease(ctx context.Context, in *ExtendLeaseRequest, opts ...grpc.CallOption) (*ExtendLeaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtendLeaseResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ExtendLease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) RegisterConsumer(ctx context.Context, in *RegisterConsumerRequest, opts ...grpc.CallOption) (*RegisterConsumerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterConsumerResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_RegisterConsumer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) UnregisterConsumer(ctx context.Context, in *UnregisterConsumerRequest, opts ...grpc.CallOption) (*UnregisterConsumerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterConsumerResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_UnregisterConsumer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ListConsumers(ctx context.Context, in *ListConsumersRequest, opts ...grpc.CallOption) (*ListConsumersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsumersResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ListConsumers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ListPending(ctx context.Context, in *ListPendingRequest, opts ...grpc.CallOption) (*ListPendingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPendingResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ListPending_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Claim(ctx context.Context, in *ClaimRequest, opts ...grpc.CallOption) (*ClaimResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Claim_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) GetWorkQueueStats(ctx context.Context, in *GetWorkQueueStatsRequest, opts ...grpc.CallOption) (*GetWorkQueueStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkQueueStatsResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_GetWorkQueueStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ListReadyMessages(ctx context.Context, in *ListReadyMessagesRequest, opts ...grpc.CallOption) (*ListReadyMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReadyMessagesResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ListReadyMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ListDLQMessages(ctx context.Context, in *ListWorkQueueDLQRequest, opts ...grpc.CallOption) (*ListWorkQueueDLQResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkQueueDLQResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ListDLQMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) ListCompleted(ctx context.Context, in *ListCompletedRequest, opts ...grpc.CallOption) (*ListCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCompletedResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_ListCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workQueuesServiceClient) Flush(ctx context.Context, in *FlushWorkQueueRequest, opts ...grpc.CallOption) (*FlushWorkQueueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FlushWorkQueueResponse)
	err := c.cc.Invoke(ctx, WorkQueuesService_Flush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkQueuesServiceServer is the server API for WorkQueuesService service.
// All implementations must embed UnimplementedWorkQueuesServiceServer
// for forward compatibility.
//
// WorkQueues provides a task queue facade with one-of-N delivery semantics.
// Unlike Streams (pub/sub fanout), WorkQueues ensure only one worker processes each message.
type WorkQueuesServiceServer interface {
	// Core Operations
	CreateWorkQueue(context.Context, *CreateWorkQueueRequest) (*CreateWorkQueueResponse, error)
	Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error)
	Dequeue(*DequeueRequest, grpc.ServerStreamingServer[DequeueResponse]) error
	Complete(context.Context, *CompleteRequest) (*CompleteResponse, error)
	Fail(context.Context, *FailRequest) (*FailResponse, error)
	ExtendLease(context.Context, *ExtendLeaseRequest) (*ExtendLeaseResponse, error)
	// Consumer Registry
	RegisterConsumer(context.Context, *RegisterConsumerRequest) (*RegisterConsumerResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	UnregisterConsumer(context.Context, *UnregisterConsumerRequest) (*UnregisterConsumerResponse, error)
	ListConsumers(context.Context, *ListConsumersRequest) (*ListConsumersResponse, error)
	// Pending Entries List (PEL) & Claims
	ListPending(context.Context, *ListPendingRequest) (*ListPendingResponse, error)
	Claim(context.Context, *ClaimRequest) (*ClaimResponse, error)
	// Admin & Introspection
	GetWorkQueueStats(context.Context, *GetWorkQueueStatsRequest) (*GetWorkQueueStatsResponse, error)
	ListReadyMessages(context.Context, *ListReadyMessagesRequest) (*ListReadyMessagesResponse, error)
	ListDLQMessages(context.Context, *ListWorkQueueDLQRequest) (*ListWorkQueueDLQResponse, error)
	ListCompleted(context.Context, *ListCompletedRequest) (*ListCompletedResponse, error)
	Flush(context.Context, *FlushWorkQueueRequest) (*FlushWorkQueueResponse, error)
	mustEmbedUnimplementedWorkQueuesServiceServer()
}

// UnimplementedWorkQueuesServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkQueuesServiceServer struct{}

func (UnimplementedWorkQueuesServiceServer) CreateWorkQueue(context.Context, *CreateWorkQueueRequest) (*CreateWorkQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkQueue not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Enqueue(context.Context, *EnqueueRequest) (*EnqueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enqueue not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Dequeue(*DequeueRequest, grpc.ServerStreamingServer[DequeueResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Dequeue not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Complete(context.Context, *CompleteRequest) (*CompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Fail(context.Context, *FailRequest) (*FailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fail not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ExtendLease(context.Context, *ExtendLeaseRequest) (*ExtendLeaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtendLease not implemented")
}
func (UnimplementedWorkQueuesServiceServer) RegisterConsumer(context.Context, *RegisterConsumerRequest) (*RegisterConsumerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterConsumer not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedWorkQueuesServiceServer) UnregisterConsumer(context.Context, *UnregisterConsumerRequest) (*UnregisterConsumerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterConsumer not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ListConsumers(context.Context, *ListConsumersRequest) (*ListConsumersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConsumers not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ListPending(context.Context, *ListPendingRequest) (*ListPendingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPending not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Claim(context.Context, *ClaimRequest) (*ClaimResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Claim not implemented")
}
func (UnimplementedWorkQueuesServiceServer) GetWorkQueueStats(context.Context, *GetWorkQueueStatsRequest) (*GetWorkQueueStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkQueueStats not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ListReadyMessages(context.Context, *ListReadyMessagesRequest) (*ListReadyMessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReadyMessages not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ListDLQMessages(context.Context, *ListWorkQueueDLQRequest) (*ListWorkQueueDLQResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDLQMessages not implemented")
}
func (UnimplementedWorkQueuesServiceServer) ListCompleted(context.Context, *ListCompletedRequest) (*ListCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCompleted not implemented")
}
func (UnimplementedWorkQueuesServiceServer) Flush(context.Context, *FlushWorkQueueRequest) (*FlushWorkQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Flush not implemented")
}
func (UnimplementedWorkQueuesServiceServer) mustEmbedUnimplementedWorkQueuesServiceServer() {}
func (UnimplementedWorkQueuesServiceServer) testEmbeddedByValue()                           {}

// UnsafeWorkQueuesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkQueuesServiceServer will
// result in compilation errors.
type UnsafeWorkQueuesServiceServer interface {
	mustEmbedUnimplementedWorkQueuesServiceServer()
}

func RegisterWorkQueuesServiceServer(s grpc.ServiceRegistrar, srv WorkQueuesServiceServer) {
	// If the following call pancis, it indicates UnimplementedWorkQueuesServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkQueuesService_ServiceDesc, srv)
}

func _WorkQueuesService_CreateWorkQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWorkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).CreateWorkQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_CreateWorkQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).CreateWorkQueue(ctx, req.(*CreateWorkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Enqueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Enqueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Enqueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Enqueue(ctx, req.(*EnqueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Dequeue_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DequeueRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkQueuesServiceServer).Dequeue(m, &grpc.GenericServerStream[DequeueRequest, DequeueResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WorkQueuesService_DequeueServer = grpc.ServerStreamingServer[DequeueResponse]

func _WorkQueuesService_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Complete(ctx, req.(*CompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Fail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Fail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Fail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Fail(ctx, req.(*FailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ExtendLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtendLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ExtendLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ExtendLease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ExtendLease(ctx, req.(*ExtendLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_RegisterConsumer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterConsumerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).RegisterConsumer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_RegisterConsumer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).RegisterConsumer(ctx, req.(*RegisterConsumerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_UnregisterConsumer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterConsumerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).UnregisterConsumer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_UnregisterConsumer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).UnregisterConsumer(ctx, req.(*UnregisterConsumerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ListConsumers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsumersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ListConsumers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ListConsumers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ListConsumers(ctx, req.(*ListConsumersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ListPending_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPendingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ListPending(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ListPending_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ListPending(ctx, req.(*ListPendingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Claim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Claim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Claim_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Claim(ctx, req.(*ClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_GetWorkQueueStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkQueueStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).GetWorkQueueStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_GetWorkQueueStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).GetWorkQueueStats(ctx, req.(*GetWorkQueueStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ListReadyMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReadyMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ListReadyMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ListReadyMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ListReadyMessages(ctx, req.(*ListReadyMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ListDLQMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkQueueDLQRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ListDLQMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ListDLQMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ListDLQMessages(ctx, req.(*ListWorkQueueDLQRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_ListCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).ListCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_ListCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).ListCompleted(ctx, req.(*ListCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkQueuesService_Flush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushWorkQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkQueuesServiceServer).Flush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkQueuesService_Flush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkQueuesServiceServer).Flush(ctx, req.(*FlushWorkQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkQueuesService_ServiceDesc is the grpc.ServiceDesc for WorkQueuesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkQueuesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flo.v1.WorkQueuesService",
	HandlerType: (*WorkQueuesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWorkQueue",
			Handler:    _WorkQueuesService_CreateWorkQueue_Handler,
		},
		{
			MethodName: "Enqueue",
			Handler:    _WorkQueuesService_Enqueue_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _WorkQueuesService_Complete_Handler,
		},
		{
			MethodName: "Fail",
			Handler:    _WorkQueuesService_Fail_Handler,
		},
		{
			MethodName: "ExtendLease",
			Handler:    _WorkQueuesService_ExtendLease_Handler,
		},
		{
			MethodName: "RegisterConsumer",
			Handler:    _WorkQueuesService_RegisterConsumer_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _WorkQueuesService_Heartbeat_Handler,
		},
		{
			MethodName: "UnregisterConsumer",
			Handler:    _WorkQueuesService_UnregisterConsumer_Handler,
		},
		{
			MethodName: "ListConsumers",
			Handler:    _WorkQueuesService_ListConsumers_Handler,
		},
		{
			MethodName: "ListPending",
			Handler:    _WorkQueuesService_ListPending_Handler,
		},
		{
			MethodName: "Claim",
			Handler:    _WorkQueuesService_Claim_Handler,
		},
		{
			MethodName: "GetWorkQueueStats",
			Handler:    _WorkQueuesService_GetWorkQueueStats_Handler,
		},
		{
			MethodName: "ListReadyMessages",
			Handler:    _WorkQueuesService_ListReadyMessages_Handler,
		},
		{
			MethodName: "ListDLQMessages",
			Handler:    _WorkQueuesService_ListDLQMessages_Handler,
		},
		{
			MethodName: "ListCompleted",
			Handler:    _WorkQueuesService_ListCompleted_Handler,
		},
		{
			MethodName: "Flush",
			Handler:    _WorkQueuesService_Flush_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Dequeue",
			Handler:       _WorkQueuesService_Dequeue_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "flo/v1/workqueues.proto",
}
